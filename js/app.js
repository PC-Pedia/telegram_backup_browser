// Generated by CoffeeScript 1.4.0

window.angular.module('myApp.controllers', []).controller('MainController', function($scope, $location, MtpApiManager, CryptoWorker, $timeout) {
  var _this = this;
  window.mainController = this;
  this.loading = false;
  this.step = 1;
  this.log = "";
  this.status = "";
  this.db = null;
  this.set_status = function(status) {
    return _this.log = "" + ((new Date()).toString()) + " --- " + status + "\n" + _this.log;
  };
  this.clear_status = function() {};
  this.set_status("Checking login state");
  MtpApiManager.invokeApi('account.updateProfile', {}, {}).then(function(result) {
    _this.clear_status();
    _this.user = result;
    return _this.open_database(result);
  })["catch"](function(error) {
    _this.clear_status();
    _this.user = null;
    return error.handled = true;
  });
  this.step_1_done = function() {
    _this.loading = true;
    return MtpApiManager.invokeApi('auth.sendCode', {
      flags: 0,
      phone_number: _this.phone,
      api_id: Config.App.id,
      api_hash: Config.App.hash,
      lang_code: 'en'
    }, {
      createNetworker: true
    }).then(function(result) {
      _this.phone_code_hash = result.phone_code_hash;
      _this.loading = false;
      return _this.step = 2;
    })["catch"](function(error) {
      if (error.code === 400 && error.type === 'PHONE_PASSWORD_PROTECTED') {
        _this.loading = false;
        _this.step = 3;
        return error.handled = true;
      }
    });
  };
  this.step_2_done = function() {
    _this.loading = true;
    return MtpApiManager.invokeApi('auth.signIn', {
      phone_number: _this.phone,
      phone_code_hash: _this.phone_code_hash,
      phone_code: _this.phone_code
    }, {}).then(function(result) {
      _this.user = result.user;
      return _this.open_database(_this.user);
    })["catch"](function(error) {
      if (error.code === 401 && error.type === 'SESSION_PASSWORD_NEEDED') {
        _this.loading = false;
        _this.step = 3;
        return error.handled = true;
      }
    });
  };
  this.step_3_done = function() {
    var salt;
    _this.loading = true;
    salt = null;
    return MtpApiManager.invokeApi('account.getPassword', {}, {}).then(function(result) {
      return makePasswordHash(result.current_salt, _this.password, CryptoWorker).then(function(hash) {
        return MtpApiManager.invokeApi('auth.checkPassword', {
          password_hash: hash
        }, {}).then(function(result) {
          _this.user = result.user;
          return _this.open_database(result.user);
        })["catch"](_this.handle_errors)["finally"](function() {
          return _this.password = null;
        });
      })["catch"](_this.handle_errors);
    });
  };
  this.start_download = function() {
    _this.loading = true;
    _this.set_status("Fetching dialogs");
    return MtpApiManager.invokeApi('messages.getDialogs', {
      offset_date: 0,
      offset_id: 0,
      offset_peer: {
        _: 'inputPeerEmpty'
      },
      limit: 100,
      max_id: -1
    }, {}).then(_this.process_dialog_list)["catch"](_this.handle_errors);
  };
  this.process_dialog_list = function(dialogs) {
    var max_id, max_ids, max_known_id;
    _this.set_status("Parsing dialog list");
    _this.set_status("Got " + dialogs.dialogs.length + " Chats");
    max_ids = dialogs.dialogs.map(function(x) {
      return x.top_message;
    });
    max_id = Math.max.apply(Math, max_ids);
    _this.set_status("Newest message id at telegram is " + max_id);
    max_known_id = 0;
    return _this.db.messages.orderBy(":id").last().then(function(last_msg) {
      return max_known_id = last_msg.id;
    })["catch"](function() {})["finally"](function() {
      _this.set_status("Newest messages id in cache is " + max_known_id);
      if (max_known_id >= max_id) {
        _this.set_status("No new messages. Doing nothing.");
        return _this.loading = false;
      } else {
        _this.message_ids_to_load = Array.from(new Array(max_id + 1).keys()).slice(max_known_id + 1);
        _this.message_count = max_id;
        _this.progress_name = "Messages loaded";
        _this.progress_max = _this.message_ids_to_load.length;
        _this.progress_current = 0;
        return _this.download_messages;
      }
    });
  };
  return this.download_messages(function() {
    var ids;
    ids = _this.message_ids_to_load.splice(0, 200);
    _this.set_status("Downloading " + ids.length + " messages, starting with ID=" + ids[0] + "...");
    return MtpApiManager.invokeApi('messages.getMessages', {
      id: ids
    }, {}).then(function(result) {
      _this.temp_result = result;
      _this.set_status("Saving the data...");
      return _this.db.transaction('rw', _this.db.messages, _this.db.people, _this.db.chats, function() {
        _this.db.messages.bulkPut(result.messages);
        _this.db.people.bulkPut(result.users);
        return _this.db.chats.bulkPut(result.chats);
      }).then(function() {
        _this.progress_current += ids.length;
        if (_this.message_ids_to_load.length > 0) {
          _this.set_status("Short delay...");
          return $timeout(_this.download_messages, 750);
        } else if (_this.auto_download) {
          _this.set_status("Starting auto-download of missing media");
          return _this.download_missing_media();
        } else {
          _this.set_status("Done");
          return _this.progress_name = "";
        }
      });
    })["catch"](handle_errors);
  });
  /*	
  	main.download_missing_media = function() {
  		main.set_status("Fetching all messages with media from cache...");
  		main.db.messages.filter(function(x){return x.media!=null;}).toArray().then(function(array) {
  			main.set_status("Found " + array.length + " messages with media.");
  			main.set_status("Filtering stuff to download...");
  			var new_array = array.filter(function(elm) {
  				if (
  					elm.media._=="messageMediaPhoto" || 
  					elm.media._=="messageMediaDocument"
  				) return true;
  				
  				if (
  					elm.media._=="messageMediaWebPage" ||
  					elm.media._=="messageMediaGeo"
  				) return false;
  				
  				main.set_status("Unsupported media: " + elm.media._);
  				return false;
  			});
  			main.set_status("Remaining messages with stuff to download: " + new_array.length);
  			main.set_status("Checking the cache for already downloaded files...");
  			var files = [];
  			main.db.files.toCollection().primaryKeys().then(function(f){
  				files = f;
  			}).catch(function(e){}).finally(function() {
  				main.media_to_download = new_array.filter(function(elm) { return files.indexOf(elm.id)==-1; });
  				main.set_status("Remaining messages with not-yet-downloaded stuff: " + main.media_to_download.length);
  				main.progress_name = "Media to download";
  				main.progress_max = main.media_to_download.length;
  				main.progress_current = 0;
  				main.download_first_media();
  			});
  		});
  	}
  	
  	main.download_first_media = function() {
  		if (main.media_to_download.length == 0) {
  			main.set_status("Done.");
  			main.progress_name = "";
  		}
  		var message = main.media_to_download.shift();
  		if (message.media.photo) {
  			// Select the biggest photo size
  			var biggest = null;
  			message.media.photo.sizes.forEach(function(size) {
  				if (biggest==null || (size.h>=biggest.h && size.w>=biggest.w && size.size<=1024*1024)) biggest=size;
  			});
  			main.download_file_with_location(message.id, biggest.location, "image/jpg", "jpg");
  		} else if (message.media.document) {
  			if (message.media.document.size >= 1024*1024) {
  				main.set_status("Document of message " + message.id + " is bigger than 1 MByte. Skipping.");
  				main.download_next_media();
  				return;
  			}
  			main.download_file_without_location(message.id, message.media.document);
  			
  		} else {
  			main.set_status("Unknown media type: " + message.media._);
  			main.download_next_media();
  		}
  	}
  	
  	main.download_file_without_location = function(id, data_obj) {
  		var file = data_obj.file_name;
  		var ext = '';
  		if (file==null) {
  			ext = '.' + data_obj.mime_type.split('/')[1];
  			if (ext=='.octet-stream') ext='';
  			file = "t_" + (data_obj.type || 'file') + data_obj.id + ext;
  		}
  			
  		var loc = {_: "inputDocumentFileLocation", id: data_obj.id, access_hash: data_obj.access_hash, file_name: file, dc_id: data_obj.dc_id, size: data_obj.size};
  		
  		main.download_file_with_location(id, loc, data_obj.mimetype, ext.substr(1));
  	}
  	
  	main.download_file_with_location = function(id, location, mimetype, filetype) {
  		if (location._==null || location._=="fileLocation") location._ = "inputFileLocation";
  		MtpApiManager.invokeApi(
  			'upload.getFile',
  			{location: location, offset: 0, limit: 1024*1024},
  			{dcID: location.dc_id, fileDownload: true, createNetworker: true, noErrorBox: true}
  		).then(function(result) {
  			main.db.files.put(
  				{id: id, filetype: filetype, mimetype: mimetype, data: btoa(main.ab2str(result.bytes))}
  			).finally(main.download_next_media);
  		}).catch(main.handle_errors);
  	}
  	
  	main.download_next_media = function() {
  		main.progress_current++;
  		main.download_first_media();
  	}
  	
  	main.download_json = function() {
  		main.set_status("Creating ZIP file. This may take a few seconds...");
  		var zip = new Zlib.Zip();
  		main.db.messages.toArray().then(function(result) {
  			zip.addFile(main.str2ab(JSON.stringify(result)), { filename: main.str2ab("data.json") });
  			
  			main.set_status("Adding media files...");
  			main.db.files.toArray().then(function(files) {
  				main.progress_name = "Media files to add";
  				main.progress_max = files.length;
  				main.progress_current = 0;
  				files.forEach(function(file) {
  					var filename = "" + file.id;
  					if (file.filetype && file.filetype!=null) filename += "." + file.filetype;
  					console.log(typeof file.data);
  					zip.addFile(main.str2ab(atob(file.data)), { filename: main.str2ab(filename) });
  					main.progress_current++;
  				});
  				var data = zip.compress();
  				data = URL.createObjectURL(new Blob([data], {type: 'application/zip'}));
  				location.href = data;
  			}).catch(main.handle_errors);
  		}).catch(main.handle_errors);
  	}
  			
  	
  	main.handle_errors = function(error) {
  		console.log(error);
  		debugger;
  	}
  	
  	main.open_database = function(user) {
  		main.db = new Dexie("telegram_backup_" + user.id);
  		main.db.version(1).stores({
  			messages: 'id,date',
  			chats: 'id',
  			people: 'id',
  			files: 'id'
  		});
  		main.db.open().catch(main.handle_errors);
  	}
  	
  	main.test = function() {
  		$.getScript('test.js', function() { doTest(main); });
  	}
  	
  	main.str2ab = function(str) {
  		var array = new (window.Uint8Array !== void 0 ? Uint8Array : Array)(str.length);
  		for (var i=0; i<str.length; i++) array[i] = str.charCodeAt(i) & 0xff;
  		return array;
  	}
  	
  	main.ab2str = function(array) {
  		var target = new Array(array.length);
  		for (var i=0; i<array.length; i++) target[i] = String.fromCharCode(array[i]);
  		return target.join('');
  	}
  });
  
  myApp = angular.module('myApp', [
  	'izhukov.utils',
  	'izhukov.mtproto',
  	'izhukov.mtproto.wrapper',
  	'myApp.controllers',
  	'myApp.i18n'])
  .run(function(MtpApiManager) {
  	// code here
  })
  .factory('$modalStack', function() {
  	var $modalStack = {};
  	$modalStack.dismissAll = function() {}
  	return $modalStack;
  })
  .service('ErrorService', function() {
  })
  .service('TelegramMeWebService', function() {
  	var self = this;
  	self.setAuthorized = function(val) { console.log("TelegramMeWebService.setAuthorized(" + val + ")"); };
  });
  */

});
